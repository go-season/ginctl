package mock

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"github.com/go-season/ginctl/pkg/util"
	"github.com/go-season/ginctl/pkg/util/file"
	"github.com/go-season/ginctl/pkg/util/str"
	"gopkg.in/yaml.v2"
)

type Client struct {
	Namespace string `yaml:"namespace"`
	Alias     string `yaml:"alias"`
	Name      string `yaml:"name"`
	Path      string `yaml:"path"`
	Method    string `yaml:"method"`
	Response  string `yaml:"response"`
}

type Config struct {
	Mock []Client `yaml:"mock"`
}

type Generator struct {
	*bytes.Buffer

	workDir string
	Config  Config
}

type Option func(*Generator)

func NewGenerator(opts ...Option) *Generator {
	gen := &Generator{
		Buffer: new(bytes.Buffer),
	}

	for _, opt := range opts {
		opt(gen)
	}

	return gen
}

func WithWorkDir(dir string) Option {
	return func(g *Generator) {
		g.workDir = dir
	}
}

func (g *Generator) Parse(file string) error {
	b, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}

	var config Config

	if err = yaml.Unmarshal(b, &config); err != nil {
		return err
	}

	g.Config = config

	return nil
}

func (g *Generator) GenMockClient() error {
	g.generateImport()
	g.generateMock()

	mockOutputDir := fmt.Sprintf("%s/pkg/mock", g.workDir)
	exists, err := file.PathExists(mockOutputDir)
	if err != nil {
		return err
	}
	if !exists {
		_ = os.Mkdir(mockOutputDir, 0755)
	}

	return g.generateFile(fmt.Sprintf("%s/pkg/mock/mock.go", g.workDir))
}

func (g *Generator) generateImport() {
	g.P("// Code generated by ginctl. DO NOT EDIT.")
	g.P()
	g.P("package mock")
	g.P()
	g.P("import (")
	g.P(strconv.Quote("github.com/bxcodec/faker/v3"))
	g.P(strconv.Quote("github.com/steinfletcher/apitest"))
	g.P(strconv.Quote("net/http"))
	for _, client := range g.Config.Mock {
		if client.Alias != "" {
			g.P(client.Alias, " ", strconv.Quote(client.Namespace))
		} else {
			g.P(strconv.Quote(client.Namespace))
		}
	}
	g.P(")")
	g.P()
}

func (g *Generator) generateMock() {
	for _, client := range g.Config.Mock {
		g.P("func ", str.ToPascal(client.Name), "Mock() *apitest.Mock {")
		if client.Alias != "" {
			g.P("var resp ", client.Alias, ".", client.Response)
		} else {
			g.P("var resp ", util.GetImportBaseName(client.Namespace), ".", client.Response)
		}
		g.P()
		g.P("_ = faker.FakeData(&resp)")
		g.P()
		g.P("return apitest.NewMock().")
		g.P(str.ToPascal(strings.ToLower(client.Method)), "(", strconv.Quote(client.Path), ").")
		g.P("RespondWith().")
		g.P("JSON(&resp).")
		g.P("Status(http.StatusOK).")
		g.P("End()")
		g.P("}")
	}
}

func (g *Generator) P(str ...string) {
	for _, v := range str {
		g.WriteString(v)
	}
	g.WriteByte('\n')
}

func (g *Generator) generateFile(file string) error {
	fset := token.NewFileSet()
	original := g.Bytes()
	fileAST, err := parser.ParseFile(fset, "", original, parser.ParseComments)
	if err != nil {
		return err
	}
	ast.SortImports(fset, fileAST)
	g.Reset()

	(&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, fileAST)
	os.Remove(file)
	fs, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer fs.Close()

	fs.Write(g.Bytes())

	return nil
}
