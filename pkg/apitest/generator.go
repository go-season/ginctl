package apitest

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/go-season/ginctl/pkg/ginctl/doc"
	"github.com/go-season/ginctl/pkg/util"
	"github.com/go-season/ginctl/pkg/util/file"
	"github.com/go-season/ginctl/pkg/util/log"
	"github.com/go-season/ginctl/pkg/util/str"
)

type FuncDecl struct {
	funcName          string
	apiPath           string
	methods           []string
	mocks             []string
	requestDefinition string
}

type Generator struct {
	*bytes.Buffer

	log             log.Logger
	workDir         string
	rootPackageName string
	packageName     string
	outPath         string
	hasMock         bool
	importPackages  []string

	funcDecls []FuncDecl
}

type Option func(*Generator)

func WithLog(log log.Logger) Option {
	return func(g *Generator) {
		g.log = log
	}
}

func WithWorkDir(dir string) Option {
	return func(g *Generator) {
		g.workDir = dir
	}
}

func NewGenerator(opts ...Option) *Generator {
	g := &Generator{
		Buffer: new(bytes.Buffer),
	}

	for _, opt := range opts {
		opt(g)
	}

	g.rootPackageName = util.GetModuleName(g.workDir)

	return g
}

func (g *Generator) GenAPITest() error {
	g.Buffer = new(bytes.Buffer)

	g.generateImport()
	g.generateMain()
	g.generateFunc()
	if g.String() != "" {
		err := g.generateFile(g.outPath)
		if err != nil {
			return err
		}
	}

	return g.generateTestBootstrap()
}

func (g *Generator) generateTestBootstrap() error {
	testPath := fmt.Sprintf("%s/test", g.workDir)
	exists, _ := file.PathExists(testPath)
	if !exists {
		_ = os.Mkdir(testPath, 0755)
	}

	exists, _ = file.PathExists(fmt.Sprintf("%s/bootstrap.go", testPath))
	if exists {
		return nil
	}

	g.Buffer = new(bytes.Buffer)

	g.P("package test")
	g.P()
	g.P("import (")
	g.P(strconv.Quote("fmt"))
	g.P(strconv.Quote("github.com/go-season/common/config"))
	g.P(strconv.Quote("github.com/fdymylja/go-querystring/query"))
	g.P(strconv.Quote("github.com/go-season/common/orm"))
	g.P(strconv.Quote("os"))
	g.P(strconv.Quote("path"))
	g.P(strconv.Quote("runtime"))
	g.P(")")
	g.P()
	g.P("func Setup() {")
	g.P("_, filename, _, _ := runtime.Caller(1)")
	g.P("_ = os.Chdir(path.Dir(path.Dir(path.Dir(path.Dir(filename)))))")
	g.P()
	g.P("if _, err := config.NewConfig(os.Getenv(", strconv.Quote("APP_ENV"), ")); err != nil {")
	g.P("panic(fmt.Sprintf(", strconv.Quote("init config failed, err: %v"), ", err))")
	g.P("}")
	g.P()
	g.P("orm.Setup()")
	g.P("query.SetDefaultTag(", strconv.Quote("form"), ")")
	g.P("}")

	return g.generateFile(fmt.Sprintf("%s/bootstrap.go", testPath))
}

func (g *Generator) generateImport() {
	//g.P("// Code generated by ginctl. DO NOT EDIT.")
	//g.P()
	g.P("package ", g.packageName)
	g.P()
	g.P("import (")
	g.P(strconv.Quote("github.com/bxcodec/faker/v3"))
	g.P(strconv.Quote("github.com/gin-gonic/gin"))
	g.P(strconv.Quote("github.com/fdymylja/go-querystring/query"))
	g.P(strconv.Quote("github.com/steinfletcher/apitest"))
	g.P(strconv.Quote("github.com/stretchr/testify/assert"))
	g.P(strconv.Quote("net/http"))
	g.P(strconv.Quote("testing"))
	g.P("utilassert ", strconv.Quote("github.com/go-season/common/util/assert"))
	g.P(strconv.Quote(fmt.Sprintf("%s/test", g.rootPackageName)))
	if g.hasMock {
		g.P(strconv.Quote(fmt.Sprintf("%s/pkg/mock", g.rootPackageName)))
	}

	for _, importPackage := range g.importPackages {
		g.P(strconv.Quote(importPackage))
	}
	g.P(")")
	g.P()
}

func (g *Generator) generateMain() {
	g.P("func TestMain(m *testing.M) {")
	g.P("test.Setup()")
	g.P()
	g.P("m.Run()")
	g.P("}")
}

func (g *Generator) generateFunc() {
	for _, decl := range g.funcDecls {
		g.P()
		g.P("func Test", decl.funcName, "(t *testing.T) {")
		g.P("r := gin.Default()")
		g.P()
		g.P("var req ", g.packageName, "type.", decl.requestDefinition)
		g.P("if err := faker.FakeData(&req); err != nil {")
		g.P("t.Fatal(err)")
		g.P("}")
		g.P()

		for _, method := range decl.methods {
			g.P("r.", strings.ToUpper(method), "(", strconv.Quote(decl.apiPath), ", ", decl.funcName, ")")
			g.P()
			if http.MethodGet == method {
				g.P("v, err := query.Values(&req)")
				g.P("if err != nil {")
				g.P("t.Fatal(err)")
				g.P("}")
				g.P()
			}
			g.P("apitest.New().")
			if decl.mocks != nil {
				mockStr := ""
				for _, mock := range decl.mocks {
					mockStr += "mock." + str.ToPascal(mock) + "Mock()"
				}
				g.P("Mocks(", mockStr, ").")
			}
			g.P("Handler(r).")
			g.P(str.ToPascal(strings.ToLower(method)), "(", strconv.Quote(decl.apiPath), ").")
			if http.MethodGet == method {
				g.P("QueryCollection(v).")
			}
			if http.MethodPost == method {
				g.P("JSON(&req).")
			}
			g.P("Expect(t).")
			g.P("Assert(utilassert.NewResponseAssertFunc(t, func(resp utilassert.Response) error {")
			g.P("assert.Equal(t, http.StatusOK, resp.Status)")
			g.P("return nil")
			g.P("})).")
			g.P("Status(http.StatusOK).")
			g.P("End()")
			g.P()
		}

		g.P("}")
	}
}

func (g *Generator) P(str ...string) {
	for _, v := range str {
		g.WriteString(v)
	}
	g.WriteByte('\n')
}

func (g *Generator) generateFile(file string) error {
	fset := token.NewFileSet()
	original := g.Bytes()
	fileAST, err := parser.ParseFile(fset, "", original, parser.ParseComments)
	if err != nil {
		return err
	}
	ast.SortImports(fset, fileAST)
	g.Reset()

	(&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, fileAST)
	os.Remove(file)
	fs, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer fs.Close()

	fs.Write(g.Bytes())

	return nil
}

func (g *Generator) Parse() error {
	pkgs := doc.NewPackagesDefinitions(doc.WithWorkdir(g.workDir))
	parser := doc.NewParser(doc.WithPackagesDefinitions(pkgs), doc.WithWorkDir(g.workDir), doc.WithExcludedDirsAndFiles(fmt.Sprintf("%s/api/rest/hello", g.workDir)))

	searchDir := fmt.Sprintf("%s/api/rest", g.workDir)
	err := parser.ParseAPI(searchDir)
	if err != nil {
		return err
	}

	return parser.Packages.RangeFiles(g.ParseInfo)
}

func (g *Generator) ParseInfo(info *doc.AstFileInfo, astFile *ast.File) error {
	g.log.WriteString(fmt.Sprintf("parsing %s\n", info.Path))
	g.packageName = util.GetPkgBaseName(filepath.Dir(info.Path))
	g.outPath = strings.TrimSuffix(info.Path, ".go") + "_test.go"
	importPackages := make([]string, 0)
	funcDecls := make([]FuncDecl, 0)
	importPackages = append(importPackages, strings.Replace(info.PackagePath, "rest", "typespec", 1)+"type")
	g.importPackages = importPackages
	for _, astDecl := range astFile.Decls {
		var funcDecl FuncDecl
		switch decl := astDecl.(type) {
		case *ast.FuncDecl:
			funcDecl.funcName = decl.Name.String()
			for _, comment := range decl.Doc.List {
				commentLine := strings.TrimSpace(strings.TrimLeft(comment.Text, "//"))
				if !strings.Contains(commentLine, "@") {
					continue
				}
				fields := strings.Fields(commentLine)
				attribute := fields[0]
				lowerAttribute := strings.ToLower(attribute)
				if lowerAttribute == "@router" {
					funcDecl.apiPath = fields[1]
					httpMethod := strings.TrimRight(strings.TrimLeft(fields[2], "["), "]")
					funcDecl.methods = strings.Split(httpMethod, ",")
				}
				if lowerAttribute == "@mock" {
					mocks := fields[1]
					funcDecl.mocks = strings.Split(mocks, ",")
				}
			}
			for _, stmt := range decl.Body.List {
				if v, ok := stmt.(*ast.DeclStmt); ok {
					if vv, ok := v.Decl.(*ast.GenDecl); ok {
						for _, spec := range vv.Specs {
							if vvv, ok := spec.(*ast.ValueSpec); ok {
								if vvv.Names[0].String() == "req" {
									switch expr := vvv.Type.(type) {
									case *ast.SelectorExpr:
										funcDecl.requestDefinition = expr.Sel.String()
										break
									}
								}
							}
						}
					}
				}
			}
			funcDecls = append(funcDecls, funcDecl)
		}
	}

	g.funcDecls = funcDecls

	return g.GenAPITest()
}
